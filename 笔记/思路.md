# MapReduceMuiltThreads

1. 通过反射的方式加载Driver类中的main方法

2. 解析配置文件

   在配置文件解析工具类中定义一个静态代码块，用Properties类解析mr.properties文件，所有配置数据保存在一个静态的Properties实例中；

   所有Key值保存在一个枚举类PropertyKeys中

3. 构造MapLaunch类（反射）

   MapLaunch类中两个方法依次执行：

   prepareFiles()

   * 清空tmppath，outputpath路径下的所有文件；

     file.delete

   * 检查inputpath路径下的所有文件，创建输入流

     fis=new FileInputStream(new File(inputpath))

     reader = new BufferReader(fis)

   splitFile()

   * 通过MRFactory，得到一个Map实例和一个MRContext实例

     Map是MyMap的父类、抽象类，MRFactory通过配置文件中给定的路径创建MyMap对象，并利用多态的特性赋给Map

     MRContext是MapReduce运行时的上下文对象，当中有write方法。

   * 获得文件总行数（lineCount=Files.lines(path).count()），按行读数据，
     * 记录下现在读到的行数
     * 更新现在读到的字节长度tmplength；
     * 如果读到行尾了：将状态标志置为true;
     * 如果tmplength达到10M，或读到行尾了：切分标志位置为true，tmplength置为0；
     * 调用MapTask的map方法：mapper.map(position, tmp, mrContext);
       * 进入MyMap中设定的计算逻辑
       * mrContext.write(key,value);
         * 进入Map阶段的write
         * 判断如果读到行尾了，就把flag置为reduce阶段
         * 通过分区号工具类获得分区号(key.toString().hashCode()&Integer.MAX_VALUE)%num;
         * 将当前KV对序列化保存到分区号对应的序列化数组里
         * 如果MapLaunch类中的splitSignal为true，说明内存中数据够多了，将这些内存中的序列化数组刷写（append）到指定文件中；

   Map阶段结束

4. 创建ReduceLaunch，执行calculate()

   * 通过MRFactory，得到一个MRContext实例

   * 根据reduce任务数创建线程池

     * pool.submit(new ReduceTaskWapper(i));

     * ReduceTaskWapper是一个Runnable接口的实现类，传入i，表示这是第i个分区的任务
       * 获取对应分区的文件路径
       * run()
         * 定义字节数组smallbuffer，
         * 利用BufferedInputStream(fis)读取临时文件，每次读完拷贝到bigbuffer
         * 读完之后反序列化，得到KVList
         * 遍历,对每一对KV放入hashMAP里
         * 传入Reduce.reduce()中reducer.reduce(next.getKey(), next.getValue(), mrContext);
           * 执行计算逻辑
           * mrContext.write(key,result);
             * Reduce阶段的write方法，首先获取输出Buffer流
             * 将KV对写入StringBuffer
             * 当StringBuffer长度大于1024或结束了的时候，写入数据
     * 删除临时文件

   任务结束